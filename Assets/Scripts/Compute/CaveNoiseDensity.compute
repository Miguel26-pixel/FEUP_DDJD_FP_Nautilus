#pragma kernel Density
#include "/Includes/Density.compute"
#include "/Includes/Noise.compute"

// Noise settings
StructuredBuffer<float3> offsets;
int octaves;
float lacunarity;
float persistence;
float noiseScale;
float noiseWeight;
float floorOffset;
float weightMultiplier;
bool closeEdges;
float hardFloor;
float hardFloorWeight;
float hardCeil;
float hardCeilWeight;
float warpEffect;
float warpFrequency;
float4 params;

float mixA;
float mixB;

float biomeScale;
float3 biomeOffset;

[numthreads(numThreads,numThreads,numThreads)]
void Density (int3 id : SV_DispatchThreadID)
{
    float3 pos = centre + id * spacing - boundsSize/2;

    if (pos.y > hardCeil) {
        return;
    }

    const float3 biomePos = float3(pos.xz * biomeScale, 0) + biomeOffset;
    const float biomeNoise = (snoise(biomePos) + 0.866025403785f) / (0.866025403785f*2.f);

    const float a = mixA;
    const float b = mixB;
    
    float multBiomeB = smoothstep(a, b, biomeNoise);
    float multBiomeA = 1 - multBiomeB;
    
    int index = indexFromCoord(id.x,id.y,id.z);

    float noise = 0;

    float frequency = noiseScale/100;
    float amplitude = 1;
    float weight = 1;

    for (int j =0; j < octaves; j ++) {
        float n = snoise(pos * frequency + offsets[j] + offset);
        float v = 1-abs(n);
        v = v*v;
        v *= weight;
        weight = saturate(v*weightMultiplier);
        noise += v * amplitude;
        amplitude *= persistence;
        frequency *= lacunarity;
    }
    
    float finalVal = -(pos.y + floorOffset) + noise * noiseWeight + (pos.y%params.x) * params.y;
    finalVal += hardFloorWeight * (pos.y < hardFloor);
    finalVal += hardCeilWeight * (pos.y > hardCeil);

    finalVal = lerp(finalVal, 24, multBiomeB);

    finalVal = clamp(finalVal, 5, 25);
    points[index] = float4(pos, finalVal);
}
